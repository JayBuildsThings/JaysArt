<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coastal Riders Voxel Scene</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; }
        canvas { display: block; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-family: sans-serif; font-weight: bold; pointer-events: none;
        }
    </style>
    

<script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="loading">Generating Voxels...</div>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- CONFIGURATION ---
        const VOXEL_SIZE = 1;
        const PALETTE = {
            sand: 0xE6C288,
            sandDark: 0xD4AF75,
            water: 0x4B9CD3,
            waterDeep: 0x3A80B0,
            grass: 0x556B2F,
            treeDark: 0x2F4F4F,
            treeLight: 0x3E6B3E,
            horseBrown: 0x8B4513,
            horseWhite: 0xF0F0F0,
            mane: 0x333333,
            clothesBlue: 0x284568,
            clothesRed: 0x8B0000,
            clothesBeige: 0xD2B48C,
            skin: 0xFFC0CB,
            stone: 0xA9A9A9,
            stoneDark: 0x808080,
            sky: 0x87CEEB,
            dogWhite: 0xFFFFFF,
            dogShadow: 0xCCCCCC
        };
        
        // Water Animation Constants
        const WATER_FLOW_SPEED = 0.5; // Z units per second (group translation for flow)
        const WAVE_SPEED = 3.0;       // How fast the wave oscillates
        const WAVE_HEIGHT = 0.3;      // Max height of the wave (vertical offset)
        const WAVE_SCALE = 0.2;       // How dense the waves are across the surface (frequency)
        
        // Dog Constants (Static)
        const DOG_BASE_X = 10;
        const DOG_BASE_Z = 10;


        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(PALETTE.sky);
        // Decreased fog by increasing the 'far' distance from 260 to 520.
        scene.fog = new THREE.Fog(PALETTE.sky, 40, 520);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
        // Current camera position: (-71.5, 58.5, 104)
        camera.position.set(-71.5, 58.5, 104); 

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 0, 0);

        // Global variables for animation
        let dogGroup; 
        let waterGroup;
        const waterMeshesData = []; // Stores meshes and original positions for wave animation

        // --- LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
        sunLight.position.set(-50, 100, 50);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 500;
        sunLight.shadow.camera.left = -100;
        sunLight.shadow.camera.right = 100;
        sunLight.shadow.camera.top = 100;
        sunLight.shadow.camera.bottom = -100;
        scene.add(sunLight);

        // --- VOXEL ENGINE ---
        const boxGeo = new THREE.BoxGeometry(VOXEL_SIZE, VOXEL_SIZE, VOXEL_SIZE);

        // Group voxels by color for the static scene
        const staticVoxelsByColor = {};
        const waterVoxelsByColor = {}; 

        /**
         * Adds a single voxel to the appropriate color group.
         * @param {number} x - X coordinate.
         * @param {number} y - Y coordinate.
         * @param {number} z - Z coordinate.
         * @param {number} colorHex - Hex color of the voxel.
         * @param {boolean} isWater - If true, adds to the animated water group.
         */
        function addVoxel(x, y, z, colorHex, isWater = false) {
            const target = isWater ? waterVoxelsByColor : staticVoxelsByColor;
            if (!target[colorHex]) {
                target[colorHex] = [];
            }
            target[colorHex].push({ x, y, z });
        }

        // --- SCENE BUILDER FUNCTIONS ---

        function buildGround() {
            // Ground Size
            const width = 80;
            const depth = 60;

            for (let x = -width/2; x < width/2; x++) {
                for (let z = -depth/2; z < depth/2; z++) {
                    // Perlin-ish noise logic for terrain variation (simplified)
                    const noise = Math.sin(x * 0.1) + Math.cos(z * 0.1);
                    let y = Math.floor(noise * 1.5) - 2;

                    // Water on the right side
                    if (x > 10 + Math.sin(z * 0.2) * 5) {
                         // Water level
                        // Added true to the addVoxel call to put these in the water group
                        addVoxel(x, -3, z, Math.random() > 0.5 ? PALETTE.water : PALETTE.waterDeep, true);
                        // Add seabed below
                        if (y < -3) addVoxel(x, y, z, PALETTE.sandDark);
                    } else {
                        // Sand/Land
                        let color = PALETTE.sand;
                        if (Math.random() > 0.8) color = PALETTE.sandDark;
                        
                        // Patches of grass/scrub
                        if (x < -10 && Math.random() > 0.7) color = PALETTE.grass;

                        addVoxel(x, y, z, color);
                        // Fill underneath to prevent floating
                        addVoxel(x, y-1, z, PALETTE.sandDark);
                    }
                }
            }
        }

        function buildCypressTree(x, z) {
            const height = 12 + Math.floor(Math.random() * 6);
            const yBase = 0; // approximate ground height

            // Trunk
            for(let i=0; i<3; i++) {
                addVoxel(x, yBase+i, z, PALETTE.horseBrown);
            }

            // Leaves (Conical shape)
            let radius = 2;
            for(let y = 2; y < height; y++) {
                if (y > height * 0.7) radius = 1;
                if (y > height * 0.9) radius = 0; // tip

                for(let lx = -radius; lx <= radius; lx++) {
                    for(let lz = -radius; lz <= radius; lz++) {
                        // Round off corners
                        if (Math.abs(lx) + Math.abs(lz) <= radius + 0.5) {
                            addVoxel(x+lx, yBase+y, z+lz, Math.random() > 0.5 ? PALETTE.treeDark : PALETTE.treeLight);
                        }
                    }
                }
            }
        }

        /**
         * Builds a horse and rider model at world coordinates (x, z), rotated by 'rotation'.
         * The rotation applies the full body.
         */
        function buildHorse(x, z, rotation, color, riderType) {
            const y = 1; // Ground offset
            
            // Helper function to calculate the position of a voxel relative to the horse's origin (x, z) 
            // after rotation around the Y-axis.
            const rotY = (lx, lz) => {
                const cos = Math.cos(rotation);
                const sin = Math.sin(rotation);
                return {
                    x: Math.round(x + lx * cos - lz * sin),
                    z: Math.round(z + lx * sin + lz * cos)
                };
            };

            // Wrapper to place a rotated voxel
            const placeRotated = (lx, ly, lz, c) => {
                const p = rotY(lx, lz);
                addVoxel(p.x, y + ly, p.z, c);
            };

            // --- HORSE MODEL (Origin centered on body, length along X-axis, now rotated) ---
            
            // Legs (Modeled on X, Z plane: [-2, -1], [2, -1], [-2, 1], [2, 1])
            [[-2, -1], [2, -1], [-2, 1], [2, 1]].forEach(coord => {
                for(let i=0; i<4; i++) placeRotated(coord[0], i, coord[1], color);
            });

            // Body (Extends from X=-3 to 3, Z=-1 to 1)
            for(let bx=-3; bx<=3; bx++) {
                for(let by=4; by<=6; by++) {
                    for(let bz=-1; bz<=1; bz++) {
                        placeRotated(bx, by, bz, color);
                    }
                }
            }

            // Neck (Extends towards +X)
            for(let nx=2; nx<=4; nx++) {
                for(let ny=6; ny<=9; ny++) {
                    placeRotated(nx, ny, 0, color);
                }
            }
            
            // Head (Positioned around X=5)
            placeRotated(5, 10, 0, color); 
            placeRotated(6, 10, 0, color); // Snout
            placeRotated(6, 10, 0, 0x222222); // Nose detail
            
            // Mane/Tail (Along the spine/rear, X=-4, X=4)
            for(let my=7; my<=9; my++) placeRotated(4, my, 0, PALETTE.mane); // Mane
            placeRotated(-4, 6, 0, PALETTE.mane); // Tail start
            placeRotated(-5, 5, 0, PALETTE.mane);
            placeRotated(-6, 4, 0, PALETTE.mane);
            
            // --- RIDER ---
            const riderLegColor = PALETTE.clothesBeige;
            const riderCoatColor = riderType === 'A' ? PALETTE.clothesBlue : PALETTE.clothesRed;
            
            // Rider Legs (straddling X=-1 to 1)
            for(let ly=5; ly<=6; ly++) {
                placeRotated(-1, ly, 0, riderLegColor);
                placeRotated(1, ly, 0, riderLegColor);
            }

            // Rider Torso (Centered at X=0)
            for(let ry=7; ry<=9; ry++) {
                for(let rz=-1; rz<=1; rz++) { 
                     placeRotated(0, ry, rz, riderCoatColor);
                }
            }
            
            // Rider Head
            placeRotated(0, 10, 0, PALETTE.skin);
            
            // Hat
            placeRotated(0, 11, 0, 0x111111);
            placeRotated(1, 11, 0, 0x111111); // brim
            placeRotated(-1, 11, 0, 0x111111);
        }

        function buildWalker(x, z) {
            const y = 0;
            // Legs
            addVoxel(x, y, z, PALETTE.clothesBeige);
            addVoxel(x, y+1, z, PALETTE.clothesBeige);
            addVoxel(x, y+2, z, PALETTE.clothesBeige);
            
            // Torso
            addVoxel(x, y+3, z, 0x223344); // Dark jacket
            addVoxel(x, y+4, z, 0x223344);

            // Head
            addVoxel(x, y+5, z, PALETTE.skin);
            addVoxel(x, y+6, z, 0x222222); // Hat

            // Basket (approximated)
            addVoxel(x+1, y+3, z, PALETTE.sandDark);
        }

        function buildFort(x, z) {
            // Simple wall structure
            for(let dx=0; dx<15; dx++) {
                for(let dy=0; dy<8; dy++) {
                     // Rampart shape
                    if (dy < 6 || dx % 2 === 0) {
                        addVoxel(x+dx, dy-2, z, PALETTE.stone);
                        addVoxel(x+dx, dy-2, z+1, PALETTE.stoneDark); // depth
                    }
                }
            }
        }

        function buildBackgroundMountains() {
            for(let x=-50; x<50; x+=2) {
                // Far Z
                const z = -40; 
                // Height based on sine waves to simulate mountain range
                const height = 15 + Math.sin(x * 0.05) * 10 + Math.sin(x * 0.15) * 5;
                
                for(let y=-2; y<height; y+=2) {
                     // We simulate "voxels" by placing blocks, but just a wall of them
                    addVoxel(x, y, z - Math.random()*2, 0x887799); // Purpleish mountain color
                }
            }
        }

        /**
         * Builds a small puppy model using coordinates relative to the model's center (0, 0, 0).
         * @returns {object} Dog's voxel data grouped by color.
         */
        function buildPuppy(rotation) {
            const y = -1; // Puppy sits closer to ground
            const dogVoxels = {}; // Local grouping by color for InstancedMesh later

            // Helper to rotate points around the puppy center (0,0)
            const rotY = (lx, lz) => {
                const cos = Math.cos(rotation);
                const sin = Math.sin(rotation);
                return {
                    // Standard Y-axis rotation logic
                    x: Math.round(lx * cos - lz * sin),
                    z: Math.round(lx * sin + lz * cos)
                };
            };

            // Wrapper to place a rotated voxel relative to the group origin (0,0,0)
            const placeRotated = (lx, ly, lz, c) => {
                const p = rotY(lx, lz);
                const colorHex = c;
                if (!dogVoxels[colorHex]) {
                    dogVoxels[colorHex] = [];
                }
                // Positions are relative to the group origin (0, 0, 0)
                dogVoxels[colorHex].push({ x: p.x, y: y + ly, z: p.z });
            };

            // --- PUPPY MODEL (Length along X-axis, now rotated) ---

            // Body (X=-1 to 1, Z=0)
            for(let bx=-1; bx<=1; bx++) {
                placeRotated(bx, 1, 0, PALETTE.dogWhite);
                placeRotated(bx, 2, 0, PALETTE.dogWhite);
            }

            // Head (X=2)
            placeRotated(2, 3, 0, PALETTE.dogWhite); 
            placeRotated(3, 3, 0, PALETTE.dogWhite); // Snout

            // Ears (X=1, Z=-1 and 1)
            placeRotated(1, 4, -1, PALETTE.dogShadow);
            placeRotated(1, 4, 1, PALETTE.dogShadow);

            // Legs (X=-1 and 1, Z=-1 and 1)
            placeRotated(-1, 0, -1, PALETTE.dogWhite);
            placeRotated(1, 0, -1, PALETTE.dogWhite);
            placeRotated(-1, 0, 1, PALETTE.dogWhite);
            placeRotated(1, 0, 1, PALETTE.dogWhite);
            
            return dogVoxels;
        }

        /**
         * Creates an InstancedMesh Group from a structured voxel data object.
         * For water voxels, it also populates the global waterMeshesData array for wave animation.
         * @param {object} voxelData - Object where keys are color hexes and values are arrays of {x, y, z} positions.
         * @param {boolean} isWaterGroup - Flag to indicate if this is the water group.
         * @returns {THREE.Group} A group containing InstancedMeshes, one per color.
         */
        function createInstancedMeshGroup(voxelData, isWaterGroup = false) {
            const group = new THREE.Group();

            Object.entries(voxelData).forEach(([colorStr, positions]) => {
                if (positions.length === 0) return;
                
                const color = parseInt(colorStr);
                const geometry = boxGeo;
                
                const isWater = isWaterGroup && (color === PALETTE.water || color === PALETTE.waterDeep);

                const material = new THREE.MeshStandardMaterial({ 
                    color: color, 
                    roughness: 0.8,
                    // Apply transparency for water
                    transparent: isWater,
                    opacity: isWater ? 0.9 : 1.0 
                });
                const mesh = new THREE.InstancedMesh(geometry, material, positions.length);

                const dummy = new THREE.Object3D();

                // If this is the water group, store its data for animation
                if (isWater) {
                    waterMeshesData.push({
                        mesh: mesh,
                        // Store copies of the original positions for calculating the wave offset
                        originalPositions: positions.map(p => ({ x: p.x, y: p.y, z: p.z })),
                        dummy: new THREE.Object3D() // Separate dummy object for matrix updates
                    });
                }

                positions.forEach((pos, i) => {
                    // Set the initial position matrix
                    dummy.position.set(pos.x, pos.y, pos.z);
                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);
                });

                mesh.instanceMatrix.needsUpdate = true;
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                group.add(mesh);
            });
            return group;
        }

        // --- GENERATE SCENE CONTENT ---
        
        buildGround();
        
        const horseAndDogRotation = Math.PI * 0.5; 

        const frontZ = 8; 
        const brownHorseX = -2; 
        const whiteHorseX = 5; 
        const whiteHorseZOffset = -6; 

        // Brown Horse (Left, closer to front)
        buildHorse(brownHorseX, frontZ, horseAndDogRotation, PALETTE.horseBrown, 'A'); 
        
        // White Horse (Right, further back)
        buildHorse(whiteHorseX, frontZ + whiteHorseZOffset, horseAndDogRotation, PALETTE.horseWhite, 'B');

        // Trees on the Left
        buildCypressTree(-25, -5);
        buildCypressTree(-28, 5);
        buildCypressTree(-30, -15);
        buildCypressTree(-22, -20);

        // Walker on the path
        buildWalker(-12, 15);

        // Puppy Group Creation (Static)
        const dogVoxelData = buildPuppy(horseAndDogRotation); 
        dogGroup = createInstancedMeshGroup(dogVoxelData, false); 
        dogGroup.position.set(DOG_BASE_X, 0, DOG_BASE_Z); 
        scene.add(dogGroup);

        // Fort on the right background
        buildFort(20, -20);
        
        // Mountains
        buildBackgroundMountains();


        // --- RENDERING VOXELS ---
        // Convert the static parts and water parts into separate InstancedMesh groups
        const voxelGroup = createInstancedMeshGroup(staticVoxelsByColor, false); // Static parts
        waterGroup = createInstancedMeshGroup(waterVoxelsByColor, true); // Animated water parts

        scene.add(voxelGroup);
        scene.add(waterGroup); 
        document.getElementById('loading').style.display = 'none';

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now() * 0.001;

            // 1. WATER FLOW (Group Translation)
            // Shifts the entire water plane along Z for the flowing illusion
            if (waterGroup) {
                waterGroup.position.z = (time * WATER_FLOW_SPEED) % VOXEL_SIZE;
            }

            // 2. WATER WAVES (InstancedMesh Matrix Update)
            // Iterates through every water voxel to apply vertical wave motion
            for (const meshData of waterMeshesData) {
                const mesh = meshData.mesh;
                const dummy = meshData.dummy;
                const originalPositions = meshData.originalPositions;

                for (let i = 0; i < originalPositions.length; i++) {
                    const pos = originalPositions[i];
                    
                    // Calculate wave offset based on X/Z coordinates and time
                    const waveY = Math.sin(
                        pos.x * WAVE_SCALE + 
                        pos.z * WAVE_SCALE * 0.5 + // Adjust Z scale slightly differently for variety
                        time * WAVE_SPEED
                    ) * WAVE_HEIGHT;

                    // Set the voxel's relative position within the group
                    // X and Z are original; Y is original + wave offset
                    dummy.position.set(
                        pos.x, 
                        pos.y + waveY, 
                        pos.z
                    );

                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);
                }
                // Tell Three.js the matrices have been updated
                mesh.instanceMatrix.needsUpdate = true;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
